Now that we've covered basic object types and some commands to explore and work with them, we will cover a slightly more complex type of object: lists. Lists have similarities to data frames, which we have introduced briefly in previous lessons. In this lesson, you will learn about the structure of list objects, how to create them, and how to subset them.

Previously, you have learned about basic classes of objects in R. These included character, integer, numeric, logical, and factor objects. In particular, we covered the creation of simple vectors of objects in these classes. These simple vectors are a collection of items all of the same class. In other words, each slot of these simple vectors is a length-1 vector of the same class. The term slot and element are often used interchangeably. They both refer to a particular item within the collection. Lists are also a type of vector, but they are more complex than the simple vectors we have learned about so far because each slot in a list can contain objects of different classes. The objects in these slots can be simple vectors, lists, or other types of objects. Lists are a general and flexible way to store information, and it turns out that data frames, which you have learned about in previous lessons, are a special cases of lists. As you learn how to create and work with lists in the remainder of this lesson, we will also cover connections to working with data frames.

The main way to create a list from scratch in R is with the list function. The list function takes an arbitary number of arguments and creates a list with the specified objects. For example, we may conduct a poll in a first grade classroom and ask students to name some numbers, animals, and colors that come to mind. In the example here, we have created a list with three slots to store the responses for one student. In the first slot, we have a numeric vector containing three numbers. In the second, we have a character vector containing two animal names. In the third, we have a character vector containing six colors. Within the list function, each of these objects is separated with a comma. This means that the `length` of the list is three -- one for the numbers, one for the animal names, and one for the colors, but the lengths of the responses within each list differs for each slot, where the length of the first slot would be 3 because it contains three numbers, 2 for the animal names, and then 6 for the six colors.  When we print this object to the screen, it looks as shown here. The double square brackets indicate the slot number, or element number. So bracket bracket 1 indicates the first slot or first element of the list, and we see that this first element is a length-3 numeric vector. The bracket bracket 2 indicates the second element, and we see that it is a length-2 character vector. The bracket bracket 3 indicates the third slot, and we see that it is a length-6 character vector. The double bracket notation alludes to one way that we can access certain elements of a list. We will cover this in detail in the next section of this lesson.

The information contained in this object would be improved with labels for the three list elements. This is achieved by adding names to the list. As we learned about in the Basic Commands lesson, we can do this with the names function. Now when we display the object, we can see these labels. The double square brackets have been replaced with dollar sign label where label is one of the names that we just entered. Similar to the double bracket notation, the dollar sign notation here indicates another way that we can access certain elements of a list. We will cover this in detail in the next section of this lesson.

We can also specify the names of the list elements from the start in the `list` function. Let's create another list object that contains poll responses for a second student. We can specify the names as argument names in the `list` function by stating the name of each slot in the list followed by an equals sign and then the values you want in that slot in the list after. Again, each slot is separated by a comma. When we display this object, we see that the names have been added automatically.

To highlight the flexibility and complexity of lists, note that lists can be contained within lists! We create a new list object that contains the responses for both students. Here we did not specify labels with argument names, so when we print this object, we see the double square bracket notation return.

If we had specified argument names to label this list, the resulting object would look as follows. In the printed output, the double brackets have been replaced with dollar signs followed by the corresponding name.

We mentioned at the start of this lesson that data frames are a special case of lists. In particular, data frames are lists where each element is a simple vector of the same length. In the car information data frame subset shown here, each column from m p g to carb is a simple vector. They are all either numeric or integer vectors of length 6. The car models listed on the right hand side do not actually form a column in the data frame, but rather, they are the row names of the data frame. This is a special feature of data frames that lists do not have.

We can see the relationship between data frames and lists by using the coercion function as dot list. We can see the familiar dollar sign notation indicating that the names of the list correspond to the column names of the data frame. We can also see that the simple vectors in each of these slots has length 6. Here, when displayed as a list, each column from the data frame is now a different element of the list. This is meant to highlight the fact that data frames and lists are related. All data frames are lists. But, data have the special constraint that each element must contain the same number of items as all the other elements in the data frame and the special ability to have row names. Thus, data frames are less flexible than lists.

It is often the case that we want to work with part of the information in an object, but not all of it. As alluded to in the previous section, we can subset lists using double square bracket or dollar sign notation. Because data frames are a special type of list, data frames can also be subset using double bracket or dollar sign notation. In addition to double bracket and dollar sign notation, we will cover single bracket notation for subsetting, and we will discuss the differences between these approaches.

When using double square brackets, either an integer of a character string is specified within the brackets. An integer specified the index, or the position, within the list to extract. A character string specifies that the extraction should be done by name. The example here shows how both of these methods can be used to extract the second element of the list l. Note that the extracted objects are character vectors, which we can see with the class function. This is in contrast to the class of l being a list.

This works similarly for data frames. The example here uses the same idea for a subset of the iris data frame object.

When using dollar sign notation for subsetting, the syntax is object dollar sign name, where object is the name of the list or data frame object, and name is the label for the element you want to extract. Here, in contrast to double square bracket notation, we must have names for the elements we want to extract. In the example here, we extract the element named b in the list object l, and see that the extracted object is a character vector.

Here we extract the Sepal dot Width column in the iris subset data frame, and see that the extracted object is a numeric vector.

When using either double square brackets or dollar signs to extract list/data frame elements, the subsetting is simplifying the output. That is, the original object was a list/data frame and the extracted object is simpler than a list - it is a simple vector. The opposite of a subsetting operation that simplifies the class of the output is a subsetting observation that preserves the class of the output. For lists/data frames this means that the output of the subsetting is also a list/data frame. Class preservation is achieved using single square bracket subsetting. 

As with double square bracket subsetting, an integer index or a character string can be specified with the brackets. Here we can tell from the printed output that the extracted output is a list because we can see the dollar sign b printed in the output. We can also verify this with the class function.

In the example here, we show the same for the iris subset data frame. Here we can tell from the printed output that the extracted output is a list because we can see that it is printed in a column. We can also verify this with the class function.

Lists are a flexible way to store complex data. We have seen how to create lists using the `list` function in this lesson. As you move through the course, you will learn about ways of getting data and information into R that create list objects automatically. Working with subsets of data will be a daily part of your work routine, so familiarity with subsetting operations will be vital. Sometimes when data is acquired, labels will be present, and sometimes it won't, so it is important to be comfortable with knowing when integer indices can be used to subset. Knowing the difference between class-simplifying and class-preserving subsetting operations is also important so that you know exactly what type of object you are working with. You will gain an appreciation for this as you move through the courses and work on projects.
